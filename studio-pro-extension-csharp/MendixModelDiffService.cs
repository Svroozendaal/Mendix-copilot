using System.Text.Json;

namespace AutoCommitMessage;

/// <summary>
/// Computes element-level Mendix model differences from two JSON dumps generated by <c>mx dump-mpr</c>.
/// </summary>
public static class MendixModelDiffService
{
    private static readonly ElementDescriptor[] SupportedElements =
    {
        new("Entity", "DomainModels$Entity"),
        new("Page", "Pages$Page"),
        new("Microflow", "Microflows$Microflow"),
    };

    private static readonly string[] NameFields = { "$QualifiedName", "name", "$ID" };
    private static readonly string[] IdFields = { "$QualifiedName", "name", "$ID" };
    private static readonly HashSet<string> IgnoredDetailFields = new(StringComparer.Ordinal)
    {
        "$ID",
        "$Type",
        "$ContainerID",
        "$ContainerProperty",
        "$QualifiedName",
    };

    /// <summary>
    /// Compares two model dump JSON files and returns detected changes for entities, pages, and microflows.
    /// </summary>
    /// <param name="workingJson">Path to the working-copy dump JSON.</param>
    /// <param name="headJson">Path to the HEAD dump JSON.</param>
    /// <returns>Collection of model changes.</returns>
    public static List<MendixModelChange> CompareDumps(string workingJson, string headJson)
    {
        using var workingDocument = ParseDump(workingJson);
        using var headDocument = ParseDump(headJson);

        var changes = new List<MendixModelChange>();
        foreach (var descriptor in SupportedElements)
        {
            CompareSection(
                changes,
                descriptor.ElementType,
                descriptor.ModelType,
                workingDocument.RootElement,
                headDocument.RootElement);
        }

        return changes
            .OrderBy(change => change.ElementType, StringComparer.OrdinalIgnoreCase)
            .ThenBy(change => change.ElementName, StringComparer.OrdinalIgnoreCase)
            .ThenBy(change => change.ChangeType, StringComparer.OrdinalIgnoreCase)
            .ToList();
    }

    private static void CompareSection(
        List<MendixModelChange> output,
        string elementType,
        string modelType,
        JsonElement workingRoot,
        JsonElement headRoot)
    {
        var workingElements = BuildElementMap(workingRoot, modelType);
        var headElements = BuildElementMap(headRoot, modelType);

        foreach (var (elementId, workingElement) in workingElements)
        {
            if (!headElements.TryGetValue(elementId, out var headElement))
            {
                output.Add(new MendixModelChange("Added", elementType, ResolveElementName(workingElement)));
                continue;
            }

            if (!ElementsEqual(workingElement, headElement))
            {
                var details = BuildModificationDetails(headElement, workingElement);
                output.Add(new MendixModelChange("Modified", elementType, ResolveElementName(workingElement), details));
            }
        }

        foreach (var (elementId, headElement) in headElements)
        {
            if (!workingElements.ContainsKey(elementId))
            {
                output.Add(new MendixModelChange("Deleted", elementType, ResolveElementName(headElement)));
            }
        }
    }

    private static Dictionary<string, JsonElement> BuildElementMap(JsonElement root, string modelType)
    {
        var map = new Dictionary<string, JsonElement>(StringComparer.OrdinalIgnoreCase);
        var unnamedCounter = 0;
        var duplicateCounter = 0;
        var stack = new Stack<JsonElement>();
        stack.Push(root);

        while (stack.Count > 0)
        {
            var current = stack.Pop();
            switch (current.ValueKind)
            {
                case JsonValueKind.Object:
                    var currentType = TryReadStringProperty(current, "$Type");
                    if (string.Equals(currentType, modelType, StringComparison.OrdinalIgnoreCase))
                    {
                        var element = current.Clone();
                        var key = ResolveElementId(element);
                        if (string.IsNullOrWhiteSpace(key))
                        {
                            unnamedCounter++;
                            key = $"__unnamed_{modelType}_{unnamedCounter}";
                        }

                        if (map.TryGetValue(key, out var existing))
                        {
                            if (ElementsEqual(existing, element))
                            {
                                break;
                            }

                            duplicateCounter++;
                            key = $"{key}#{duplicateCounter}";
                        }

                        map[key] = element;
                    }

                    foreach (var property in current.EnumerateObject())
                    {
                        stack.Push(property.Value);
                    }

                    break;

                case JsonValueKind.Array:
                    foreach (var item in current.EnumerateArray())
                    {
                        stack.Push(item);
                    }

                    break;
            }
        }

        return map;
    }

    private static string ResolveElementId(JsonElement element)
    {
        foreach (var propertyName in IdFields)
        {
            var value = TryReadStringProperty(element, propertyName);
            if (!string.IsNullOrWhiteSpace(value))
            {
                return value;
            }
        }

        return ResolveElementName(element);
    }

    private static string ResolveElementName(JsonElement element)
    {
        foreach (var propertyName in NameFields)
        {
            var value = TryReadStringProperty(element, propertyName);
            if (!string.IsNullOrWhiteSpace(value))
            {
                return value;
            }
        }

        return "<unnamed>";
    }

    private static string? TryReadStringProperty(JsonElement element, string propertyName)
    {
        foreach (var property in element.EnumerateObject())
        {
            if (!string.Equals(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            if (property.Value.ValueKind == JsonValueKind.String)
            {
                return property.Value.GetString();
            }

            if (property.Value.ValueKind == JsonValueKind.Number ||
                property.Value.ValueKind == JsonValueKind.True ||
                property.Value.ValueKind == JsonValueKind.False)
            {
                return property.Value.GetRawText();
            }
        }

        return null;
    }

    private static bool ElementsEqual(JsonElement left, JsonElement right)
    {
        if (left.ValueKind != right.ValueKind)
        {
            return false;
        }

        switch (left.ValueKind)
        {
            case JsonValueKind.Object:
            {
                var leftProperties = left.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);
                var rightProperties = right.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);

                if (leftProperties.Count != rightProperties.Count)
                {
                    return false;
                }

                foreach (var (name, leftValue) in leftProperties)
                {
                    if (!rightProperties.TryGetValue(name, out var rightValue))
                    {
                        return false;
                    }

                    if (!ElementsEqual(leftValue, rightValue))
                    {
                        return false;
                    }
                }

                return true;
            }

            case JsonValueKind.Array:
            {
                var leftItems = left.EnumerateArray().ToArray();
                var rightItems = right.EnumerateArray().ToArray();
                if (leftItems.Length != rightItems.Length)
                {
                    return false;
                }

                for (var index = 0; index < leftItems.Length; index++)
                {
                    if (!ElementsEqual(leftItems[index], rightItems[index]))
                    {
                        return false;
                    }
                }

                return true;
            }

            case JsonValueKind.String:
                return string.Equals(left.GetString(), right.GetString(), StringComparison.Ordinal);

            case JsonValueKind.Number:
                return string.Equals(left.GetRawText(), right.GetRawText(), StringComparison.Ordinal);

            case JsonValueKind.True:
            case JsonValueKind.False:
                return left.GetBoolean() == right.GetBoolean();

            case JsonValueKind.Null:
            case JsonValueKind.Undefined:
                return true;

            default:
                return string.Equals(left.GetRawText(), right.GetRawText(), StringComparison.Ordinal);
        }
    }

    private sealed record ElementDescriptor(string ElementType, string ModelType);

    private static JsonDocument ParseDump(string path)
    {
        var text = File.ReadAllText(path);
        if (text.Length > 0 && text[0] == '\uFEFF')
        {
            text = text[1..];
        }

        return JsonDocument.Parse(text);
    }

    private static string? BuildModificationDetails(JsonElement previousValue, JsonElement currentValue)
    {
        if (previousValue.ValueKind != JsonValueKind.Object || currentValue.ValueKind != JsonValueKind.Object)
        {
            return null;
        }

        var previousProperties = previousValue.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);
        var currentProperties = currentValue.EnumerateObject().ToDictionary(property => property.Name, property => property.Value, StringComparer.Ordinal);
        var detailParts = new List<string>();

        foreach (var (propertyName, currentPropertyValue) in currentProperties)
        {
            if (IgnoredDetailFields.Contains(propertyName))
            {
                continue;
            }

            if (!previousProperties.TryGetValue(propertyName, out var previousPropertyValue))
            {
                detailParts.Add($"{propertyName} added");
                continue;
            }

            if (!ElementsEqual(previousPropertyValue, currentPropertyValue))
            {
                detailParts.Add(DescribePropertyChange(propertyName, previousPropertyValue, currentPropertyValue));
            }
        }

        foreach (var propertyName in previousProperties.Keys)
        {
            if (IgnoredDetailFields.Contains(propertyName))
            {
                continue;
            }

            if (!currentProperties.ContainsKey(propertyName))
            {
                detailParts.Add($"{propertyName} removed");
            }
        }

        if (detailParts.Count == 0)
        {
            return null;
        }

        const int maxParts = 4;
        var visible = detailParts.Take(maxParts).ToList();
        var summary = string.Join("; ", visible);
        var remaining = detailParts.Count - visible.Count;

        if (remaining > 0)
        {
            summary = $"{summary}; +{remaining} more";
        }

        return summary;
    }

    private static string DescribePropertyChange(string propertyName, JsonElement previous, JsonElement current)
    {
        if (previous.ValueKind == JsonValueKind.Array && current.ValueKind == JsonValueKind.Array)
        {
            var previousCount = previous.GetArrayLength();
            var currentCount = current.GetArrayLength();
            if (previousCount != currentCount)
            {
                return $"{propertyName} count {previousCount}->{currentCount}";
            }

            return $"{propertyName} entries updated";
        }

        if (IsScalar(previous.ValueKind) && IsScalar(current.ValueKind))
        {
            var previousText = FormatScalar(previous);
            var currentText = FormatScalar(current);
            if (!string.Equals(previousText, currentText, StringComparison.Ordinal))
            {
                return $"{propertyName} {previousText}->{currentText}";
            }
        }

        return $"{propertyName} updated";
    }

    private static bool IsScalar(JsonValueKind kind) =>
        kind is JsonValueKind.String or JsonValueKind.Number or JsonValueKind.True or JsonValueKind.False or JsonValueKind.Null;

    private static string FormatScalar(JsonElement value)
    {
        var text = value.ValueKind switch
        {
            JsonValueKind.String => value.GetString() ?? "null",
            JsonValueKind.True => "true",
            JsonValueKind.False => "false",
            JsonValueKind.Null => "null",
            _ => value.GetRawText(),
        };

        const int maxLength = 28;
        if (text.Length > maxLength)
        {
            text = $"{text[..maxLength]}...";
        }

        return text.Replace("\r", " ").Replace("\n", " ");
    }
}
